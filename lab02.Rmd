---
title: "Indicadores no R: pirâmides etárias"
author: "Caio Gonçalves - caio.goncalves@fjp.mg.gov.br"
date: "23-agosto-2023"
output:
  html_document: 
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

O objetivo deste tutorial produzir pirâmides etárias e calcular indicadores demográficos relacionados.

# Contextualização

## Pirâmides etárias
As pirâmides etárias desempenham um papel fundamental ao retratar visualmente a distribuição da população por faixas etárias em uma determinada sociedade. Essas representações gráficas oferecem insights valiosos para os planejadores governamentais, economistas e especialistas em políticas públicas, permitindo uma compreensão mais profunda das tendências demográficas, do envelhecimento da população e das necessidades sociais. As pirâmides etárias também são ferramentas cruciais para antecipar desafios relacionados à saúde, previdência, educação e mercado de trabalho, auxiliando na formulação de estratégias que visem atender às demandas específicas de cada faixa etária e promover um desenvolvimento sustentável a longo prazo. 


## Requisitos

A representação gráfica das pirâmides etárias ilustra uma distribuição demográfica reveladora: 
* os segmentos mais jovens compõem a base, enquanto os grupos mais idosos estão no ápice; 
* a construção desse gráfico essencial requer apenas informações sobre a quantidade de indivíduos em uma população, discriminados por gênero e faixa etária; 
* pode ser categorizados de forma simples ou em intervalos de cinco anos; 
* em geral, homens são dispostos à esquerda e mulheres à direita; 
* é possível optar por apresentar dados em idade simples ou agrupada; 
* Ao recorrer a percentagens populacionais, em vez de números absolutos, as pirâmides proporcionam uma comparação eficaz entre diferentes representações, assegurando que homens e mulheres totalizem conjuntamente 100%.

## Identificando setores

Escolha um setor em: https://censo2010.ibge.gov.br/painel/ e salve o número do setor escolhido no objeto `setor_escolhido`:

```{r setor, echo=TRUE}
setor_escolhido <- 310620005680043
```

![](pics/setor_fjp.png)

Quais dados são necessários para a construção da pirâmide? 

Para responder essa pergunta, é necessário conhecer a documentação disponível [aqui](https://ftp.ibge.gov.br/Censos/Censo_Demografico_2010/Resultados_do_Universo/Agregados_por_Setores_Censitarios/). Depois disso, o passo seguinte é importar os dados.

# Base de dados

A base de dados de agregados por setores do IBGE é uma fonte robusta e abrangente de informações socioeconômicas e demográficas que oferece um panorama detalhado das características das áreas geográficas em seu menor nível territorial. A granularidade dessas informações tornam a base de dados de agregados por setores do IBGE uma ferramenta crucial para a formulação de políticas, estudos acadêmicos e análises de mercado.

## Leitura dos dados 

Importando os dados dos arquivos *Básico*,*Pessoa11* e *Pessoa12* por existir o interesse em variáveis disponíveis nessas duas bases de dados. Em sequência organiza-se em um único dataframe *df*.

```{r download, echo=TRUE}
library(readxl)
library(tidyverse)
df.basico <- read_excel("Basico-MG.xls") %>% select("Cod_setor","Cod_municipio","Nome_do_municipio","Cod_bairro","Nome_do_bairro","Cod_subdistrito","Nome_do_subdistrito")
df.pessoa11 <- read_excel("Pessoa11_MG.xls")
df.pessoa12 <- read_excel("Pessoa12_MG.xls")

df.h <- full_join(df.basico,df.pessoa11)
df.m <- full_join(df.basico,df.pessoa12)
rm(df.pessoa11,df.pessoa12,df.basico)
```
## Verificando variáveis

O pacote [DataMaid](https://cran.r-project.org/web/packages/dataMaid/index.html) é uma ferramenta valiosa no ambiente R para a verificação, limpeza e organização eficiente de conjuntos de dados. Desenvolvido com o objetivo de aprimorar a qualidade e confiabilidade dos dados, o DataMaid oferece funcionalidades que auxiliam na identificação de valores ausentes, erros de digitação, inconsistências e outras anomalias nos dados. Além disso, permite a criação de relatórios detalhados, facilitando a compreensão das estruturas e conteúdo dos datasets, promovendo assim uma exploração mais assertiva. Com suas capacidades automatizadas de geração de sumários e gráficos descritivos, o DataMaid é uma ferramenta para cientistas de dados e analistas que desejam garantir a qualidade e integridade dos seus dados, tornando todo o processo de análise mais eficiente e confiável.

```{r verificação, echo=TRUE}
library(dataMaid)
# makeDataReport(df.h,replace = TRUE)
# makeDataReport(df.m,replace = TRUE)
```

O que foi possível verificar com o relatório produzido anteriormente? Anote para implementar na sequência, porém, em conjunto com essas mudanças, planeje os indicadores a serem calculados e identifique as alterações necessárias para tal.

## Modificando variáveis

Pensando em cada um dos seguintes indicadores: 

1. Total populacional e a proporção por sexo e idade (base para a pirâmide etária)
2. Razão de dependência
3. Índice de envelhecimento

Qual variáveis precisam ser manipuladas para obter essas informações? Realize as modificações na base necessárias para isso:

```{r variaveis, echo=TRUE}
library(tidyselect)
df.h <- df.h %>% mutate(
  Cod_setor= as.character(Cod_setor))
df.m <- df.m %>% mutate(
  Cod_setor= as.character(Cod_setor))

df.h <- replace(df.h, is.na(df.h), 0)
df.m <- replace(df.m, is.na(df.m), 0)
```

Monte o data.frame com as idades:

```{r variaveis2, echo=TRUE}
library(tidyselect)
df.h <- cbind(df.h[,1:8],df.h[,c(9:142)] %>% mutate_if(is.character, as.numeric))
df.m <- cbind(df.m[,1:8],df.m[,c(9:142)] %>% mutate_if(is.character, as.numeric))
df.h <- replace(df.h, is.na(df.h), 0)
df.m <- replace(df.m, is.na(df.m), 0)


df.h <- df.h %>% mutate(
  x00_04= V022 + V035 + V036 + V037 + V038,
  x05_09= V039 + V040 + V041 + V042 + V043,
  x10_14= V044 + V045 + V046 + V047 + V048,
  x15_19= V049 + V050 + V051 + V052 + V053,
  x20_24= V054 + V055 + V056 + V057 + V058,
  x25_29= V059 + V060 + V061 + V062 + V063,
  x30_34= V064 + V065 + V066 + V067 + V068,
  x35_39= V069 + V070 + V071 + V072 + V073,
  x40_44= V074 + V075 + V076 + V077 + V078,
  x45_49= V079 + V080 + V081 + V082 + V083,
  x50_54= V084 + V085 + V086 + V087 + V088,
  x55_59= V089 + V090 + V091 + V092 + V093,
  x60_64= V094 + V095 + V096 + V097 + V098,
  x65_69= V099 + V100 + V101 + V102 + V103,
  x70_74= V104 + V105 + V106 + V107 + V108,
  x75_79= V109 + V110 + V111 + V112 + V113,
  x80_84= V114 + V115 + V116 + V117 + V118,
  x85_mais= V119 + V120 + V121 + V122 + V123 +
            V124 + V125 + V126 + V127 + V128 +
            V129 + V130 + V131 + V132 + V133 + V134
) %>% select(Cod_setor,Cod_municipio ,     
  Nome_do_municipio,Cod_bairro ,        
  Nome_do_bairro,Cod_subdistrito ,   
  Nome_do_subdistrito,x00_04,  x05_09,             
x10_14,              x15_19,             
x20_24,              x25_29,             
x30_34,              x35_39,             
x40_44,              x45_49,             
x50_54,              x55_59,             
x60_64,              x65_69,             
x70_74,              x75_79,             
x80_84,              x85_mais)

df.m <- df.m %>% mutate(
  x00_04= V022 + V035 + V036 + V037 + V038,
  x05_09= V039 + V040 + V041 + V042 + V043,
  x10_14= V044 + V045 + V046 + V047 + V048,
  x15_19= V049 + V050 + V051 + V052 + V053,
  x20_24= V054 + V055 + V056 + V057 + V058,
  x25_29= V059 + V060 + V061 + V062 + V063,
  x30_34= V064 + V065 + V066 + V067 + V068,
  x35_39= V069 + V070 + V071 + V072 + V073,
  x40_44= V074 + V075 + V076 + V077 + V078,
  x45_49= V079 + V080 + V081 + V082 + V083,
  x50_54= V084 + V085 + V086 + V087 + V088,
  x55_59= V089 + V090 + V091 + V092 + V093,
  x60_64= V094 + V095 + V096 + V097 + V098,
  x65_69= V099 + V100 + V101 + V102 + V103,
  x70_74= V104 + V105 + V106 + V107 + V108,
  x75_79= V109 + V110 + V111 + V112 + V113,
  x80_84= V114 + V115 + V116 + V117 + V118,
  x85_mais= V119 + V120 + V121 + V122 + V123 +
            V124 + V125 + V126 + V127 + V128 +
            V129 + V130 + V131 + V132 + V133 + V134
) %>% select(Cod_setor,Cod_municipio ,     
  Nome_do_municipio,Cod_bairro ,        
  Nome_do_bairro,Cod_subdistrito ,   
  Nome_do_subdistrito,x00_04,  x05_09,             
x10_14,              x15_19,             
x20_24,              x25_29,             
x30_34,              x35_39,             
x40_44,              x45_49,             
x50_54,              x55_59,             
x60_64,              x65_69,             
x70_74,              x75_79,             
x80_84,              x85_mais)
```


# Análise dos dados

## Tamanho e distribuição populacional

Conhecer o tamanho da população de uma determinada região, país ou grupo é fundamental para o desenvolvimento sustentável, a tomada de decisões informadas e a criação de políticas que atendam às necessidades e aspirações das pessoas que compõem essa população. A seguir são sistematizadas tabelas com totais populacionais 

```{r tamanho, echo=TRUE}
library(tidyr)
df.h_long <- gather(df.h, faixas, t.pop, x00_04:x85_mais) %>% mutate(Sex = "homem")
df.m_long <- gather(df.m, faixas, t.pop, x00_04:x85_mais) %>% mutate(Sex = "mulher")
df.long <- rbind(df.h_long,df.m_long)
rm(df.h_long,df.m_long)

df.long <- df.long %>% 
 group_by(Cod_setor, Cod_municipio,
          Nome_do_municipio, Cod_bairro,
          Nome_do_bairro, Cod_subdistrito,
          Nome_do_subdistrito) %>%
  mutate(p.pop = t.pop/sum(t.pop)*100)
                                                             
   
   
library(DescTools)

df.piramide <- filter(df.long, Cod_setor==setor_escolhido)

h.pop<- subset(df.piramide,df.piramide$Sex=="homem")$p.pop
m.pop<- subset(df.piramide,df.piramide$Sex=="mulher")$p.pop
age <- c("0-4","5-9","10-14","15-19","20-24","25-29",
         "30-34","35-39","40-44","45-49","50-54",
         "55-59","60-64","65-69","70-74","75-79","80-44","85+")

PlotPyramid(h.pop, 
            m.pop,
            ylab = age, space = 0, col = c("cornflowerblue", "indianred"),
            xlim=c(-5,5),
            main="Pirâmide etária",
            lxlab="Homem", rxlab="Mulher", gapwidth=0, ylab.x=-5 )

```

## Distribuição por situação do setor

Os totais populacionais podem ser desagregados por situação do setor. Verifique se faz sentido calcular essa abertura para todos os casos a seguir:

```{r distribuição, echo=TRUE}

# setor censitário escolhido
df.piramide <- filter(df.long, Cod_setor==setor_escolhido)

h.pop<- subset(df.piramide,df.piramide$Sex=="homem")$p.pop
m.pop<- subset(df.piramide,df.piramide$Sex=="mulher")$p.pop
age <- c("0-4","5-9","10-14","15-19","20-24","25-29",
         "30-34","35-39","40-44","45-49","50-54",
         "55-59","60-64","65-69","70-74","75-79","80-44","85+")

PlotPyramid(h.pop, 
            m.pop,
            ylab = age, space = 0, col = c("cornflowerblue", "indianred"),
            xlim=c(-5,5),
            main="Pirâmide etária",
            lxlab="Homem", rxlab="Mulher", gapwidth=0, ylab.x=-5 )


# bairro escolhido
bairro_escolhido <- df$Nome_do_bairro[df$Cod_setor==setor_escolhido]
df.piramide02 <- df.long %>% filter(Nome_do_bairro==bairro_escolhido)

h.pop<- subset(df.piramide,df.piramide$Sex=="homem")$p.pop
m.pop<- subset(df.piramide,df.piramide$Sex=="mulher")$p.pop
age <- c("0-4","5-9","10-14","15-19","20-24","25-29",
         "30-34","35-39","40-44","45-49","50-54",
         "55-59","60-64","65-69","70-74","75-79","80-44","85+")

PlotPyramid(h.pop, 
            m.pop,
            ylab = age, space = 0, col = c("cornflowerblue", "indianred"),
            xlim=c(-5,5),
            main="Pirâmide etária",
            lxlab="Homem", rxlab="Mulher", gapwidth=0, ylab.x=-5 )

# Minas Gerais
tab02c <- df %>% group_by(Situacao_setor_agreg) %>% 
  summarise(t.pop = sum(V001)) %>%  
  arrange(desc(t.pop)) %>% 
  mutate(p.pop = round(t.pop/sum(t.pop)*100,1))
tab02c %>% kbl() %>% kable_minimal()

# Municípios de Minas Gerais
tab02d<- df %>% group_by(Nome_do_municipio,Situacao_setor_agreg) %>% 
  summarise(t.pop = sum(V001)) %>%  
  mutate(p.pop = round(t.pop/sum(t.pop)*100,1))
tab02d %>% head(14) %>% kbl() %>% kable_minimal()

# Subdistritos de Belo Horizonte
tab02e<- df %>% 
  filter(Nome_do_municipio == "BELO HORIZONTE") %>% 
  group_by(Nome_do_subdistrito,Situacao_setor_agreg) %>% 
  summarise(t.pop = sum(V001))%>%  
  arrange(desc(t.pop)) %>% 
  mutate(p.pop = round(t.pop/sum(t.pop)*100,1))
tab02e %>% head(14) %>% kbl() %>% kable_minimal()

# Bairros de Belo Horizonte
tab02f <- df %>% 
  filter(Nome_do_municipio == "BELO HORIZONTE") %>% 
  group_by(Nome_do_bairro,Situacao_setor_agreg) %>% 
  summarise(t.pop = sum(V001))%>%  
  arrange(desc(t.pop)) %>% 
  mutate(p.pop = round(t.pop/sum(t.pop)*100,2))
tab02f %>% head(14) %>% kbl() %>% kable_minimal()

```
## População por sexo

O mesmo pode ser realizado por sexo:

```{r sexo, echo=TRUE}

# setor censitário escolhido
tab03a <- df %>% 
  filter(Cod_setor == setor_escolhido) %>% 
  summarise(t.pop_h = sum(V045),
            t.pop_m = sum(V089),
            p.pop_h = round(sum(V045)/(t.pop_h+t.pop_m)*100,1),
            p.pop_m = round(sum(V089)/(t.pop_h+t.pop_m)*100,1),
            r.sexo = t.pop_h/t.pop_m)
tab03a %>% kbl() %>% kable_minimal()

# bairro escolhido
bairro_escolhido <- df$Nome_do_bairro[df$Cod_setor==setor_escolhido]
tab03b <- df %>% 
  filter(Nome_do_bairro == bairro_escolhido) %>% 
  summarise(t.pop_h = sum(V045),
            t.pop_m = sum(V089),
            p.pop_h = round(sum(V045)/(t.pop_h+t.pop_m)*100,1),
            p.pop_m = round(sum(V089)/(t.pop_h+t.pop_m)*100,1),
            r.sexo = t.pop_h/t.pop_m)
tab03b %>% kbl() %>% kable_minimal()

# Minas Gerais
tab03c <- df %>% 
  summarise(t.pop_h = sum(V045),
            t.pop_m = sum(V089),
            p.pop_h = round(sum(V045)/(t.pop_h+t.pop_m)*100,1),
            p.pop_m = round(sum(V089)/(t.pop_h+t.pop_m)*100,1),
            r.sexo = t.pop_h/t.pop_m)
tab03c %>% kbl() %>% kable_minimal()

# Municípios de Minas Gerais
tab03d<- df %>% group_by(Nome_do_municipio) %>% 
  summarise(t.pop_h = sum(V045),
            t.pop_m = sum(V089),
            p.pop_h = round(sum(V045)/(t.pop_h+t.pop_m)*100,1),
            p.pop_m = round(sum(V089)/(t.pop_h+t.pop_m)*100,1),
            r.sexo = t.pop_h/t.pop_m) %>% arrange(r.sexo)
tab03d %>% slice (1:10) %>% kbl() %>% kable_minimal()

# Subdistritos de Belo Horizonte
tab03e<- df %>% 
  filter(Nome_do_municipio == "BELO HORIZONTE") %>% 
  group_by(Nome_do_subdistrito) %>% 
  summarise(t.pop_h = sum(V045),
            t.pop_m = sum(V089),
            p.pop_h = round(sum(V045)/(t.pop_h+t.pop_m)*100,1),
            p.pop_m = round(sum(V089)/(t.pop_h+t.pop_m)*100,1),
            r.sexo = t.pop_h/t.pop_m) %>% arrange(r.sexo)
tab03e %>% slice(1:10) %>% kbl() %>% kable_minimal()

# Bairros de Belo Horizonte
tab03f <- df %>% 
  filter(Nome_do_municipio == "BELO HORIZONTE") %>% 
  group_by(Nome_do_bairro) %>% 
  summarise(t.pop_h = sum(V045),
            t.pop_m = sum(V089),
            p.pop_h = round(sum(V045)/(t.pop_h+t.pop_m)*100,1),
            p.pop_m = round(sum(V089)/(t.pop_h+t.pop_m)*100,1),
            r.sexo = t.pop_h/t.pop_m) %>% arrange(desc(r.sexo))
tab03f %>% slice(1:10) %>% kbl() %>% kable_minimal()

```

# Considerações finais

Produzir dados mais desagregados é algo requisitado para conhecer realidades locais, porém é necessário ter cautela nos cálculos dos indicadores dado que com populações pequenas, alguns deles não informam o que deveriam informam e perdem sentido.
